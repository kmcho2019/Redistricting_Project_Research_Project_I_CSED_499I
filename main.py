import networkx as nx
from networkx.algorithms import community
import matplotlib.pyplot as plt
import pymetis
import numpy as np
import random
import copy
import enum
import statistics
import math

'''
#General Algorithm
#1: Take G(original whole graph) and partition it into n contiguous proto-districts
#2: Gather all boundary connected components into set B(or lists of partition straddling edges)
#3: Select random node from B and switch with adjacent partition (check if the switch is valid)
 \ does not break up partitions repeat switch with new node if invalid (use nx.is_connected())
#4: Compute score for updated(pop/partisan lean/etc.) district config
#5 If new map is better keep changes
 \ If not, accept it anyway with probability R(to be determiend by exp(-kt/T), MonteCarlo Annealing
#6: Repeat process for certain amount of epoch until district configuration is optimized
'''


class Precint:
    def __init__(self, name="default", id=0, pop=0, votes=0, party_1=0, party_2=0):
        self.name = name
        self.id = id
        self.pop = pop
        self.votes = votes
        self.party_1 = party_1
        self.party_2 = party_2


class Dict_Trait(enum.Enum):
    name = 0
    id = 1
    pop = 2
    total_votes = 3
    party_1 = 4
    party_2 = 5
    party_3 = 6  # Party 3 is whoever that gets the most votes besides the top 2 parties, independent or other parties
    color = 7


test = Precint("test")


# Implement Graph Partition

# Generates square graph used for testing
def nxn_square_graph_gen(n):
    G = nx.Graph()
    for i in range(n ** 2):
        G.add_node(i)
    edge_list = []
    for j in range(n ** 2 - 1):
        if (j % n) == (n - 1) and j < n * (n - 1):
            edge_list.extend([(j, j + n)])
        elif j >= n * (n - 1):
            edge_list.extend([(j, j + 1)])
        else:
            edge_list.extend([(j, j + 1), (j, j + n)])
    G.add_edges_from(edge_list)
    return G


# Generate nxm rectangle graph(n,m):
# width n, height m
def nxm_rectangle_graph_gen(n, m):
    G = nx.Graph()
    for i in range(n * m):
        G.add_node(i)
    edge_list = []
    for j in range(n * m - 1):
        if (j % n) == (n - 1) and j < n * (m - 1):
            edge_list.extend([(j, j + n)])
        elif j >= n * (m - 1):
            edge_list.extend([(j, j + 1)])
        else:
            edge_list.extend([(j, j + 1), (j, j + n)])
    G.add_edges_from(edge_list)
    return G


# Used to convert adj_list generated by networkx into something pymetis can use to generate partition
def adj_list_to_metislist(adj_list):
    list_temp = []
    for line in adj_list:
        list_ = [int(i) for i in line.split(' ')]
        list_.pop(0)
        list_temp.append(list_)
    return list_temp


# Used to convert adj_lists (which is generator class) from networkx into python lists
def nx_gen_object_to_list(gen_object):
    list_temp = []
    for line in gen_object:
        list_ = [line]
        list_temp.extend(list_)
    return list_temp


def return_adj_list_of_graph(G: nx.Graph()) -> list:
    return_list = []
    for node in G.nodes():
        return_list.append([n for n in G.neighbors(node)])
    return return_list


# Take graph (G) and split it into n partitions return list containing lists of partition nodes
def gen_init_part(G: nx.Graph(), n: int) -> list:
    partition_node_list = []
    adj_list = return_adj_list_of_graph(G)
    n_cuts, membership = pymetis.part_graph(n, adjacency=adj_list)
    nodes_part_0 = np.argwhere(np.array(membership) == 0).ravel()
    for i in range(n):
        node_temp_list = []
        node_temp_list = np.argwhere(np.array(membership) == i).ravel()  # taken from
        # \https://github.com/inducer/pymetis#readme
        # print(node_temp_list)
        partition_node_list.append(node_temp_list)
    return partition_node_list


# Take graph (G) and partion node list and return switch one node from one partition to neighboring partition when valid
# select another node randomly if switch turns out to be invalid(i.e. breaks connection of partition)
def random_switch(G: nx.Graph(), partition_node_list: list) -> (list, bool):
    is_switched = False
    is_node_list_changed = False
    return_list = []
    new_switched_partition_node_list = copy.deepcopy(partition_node_list.copy())  # make deep copy of node list
    random_partition_num = random.randint(0, len(partition_node_list) - 1)  # select random partition to switch from
    boundary_edge_list = nx_gen_object_to_list(
        nx.edge_boundary(G, partition_node_list[random_partition_num]))  # boundary edges of partition
    random_boundary_edge_pair_index = random.randint(0,
                                                     len(boundary_edge_list) - 1)  # first node is in current partition num second node is partner
    random_boundary_edge_pair = boundary_edge_list[random_boundary_edge_pair_index]
    # find partner partition to switch to
    partner_partition_num = 0
    for kth_partition in new_switched_partition_node_list:
        if random_boundary_edge_pair[1] in kth_partition:
            break
        else:
            partner_partition_num = partner_partition_num + 1

    # switch between the two random_boundary_edge_pair nodes
    index_loc_0 = np.where(new_switched_partition_node_list[random_partition_num] == random_boundary_edge_pair[0])
    index_loc_1 = np.where(new_switched_partition_node_list[partner_partition_num] == random_boundary_edge_pair[1])
    new_switched_partition_node_list[random_partition_num][index_loc_0], \
    new_switched_partition_node_list[partner_partition_num][index_loc_1] = \
        new_switched_partition_node_list[partner_partition_num][index_loc_1], \
        new_switched_partition_node_list[random_partition_num][index_loc_0]

    # Check if the new partitions are valided(they should be connected)
    part_0 = G.subgraph(new_switched_partition_node_list[random_partition_num])
    part_1 = G.subgraph(new_switched_partition_node_list[partner_partition_num])
    fst_part_connect_state = nx.is_connected(part_0)
    snd_part_connect_state = nx.is_connected(part_1)
    if np.array_equal(np.array(new_switched_partition_node_list, dtype=object),
                      np.array(partition_node_list, dtype=object)):
        is_node_list_changed = False
    else:
        is_node_list_changed = True
    if (
            fst_part_connect_state and snd_part_connect_state and is_node_list_changed):  # is switch valid and actually happened
        is_switched = True
        return_list = new_switched_partition_node_list
    else:
        is_switched = False
        return_list = partition_node_list
    return return_list, is_switched


# Take graph (G) and partion node list and return eat one node from one neighboring partition to neighboring partition
# when valid
# select another node randomly if eat turns out to be invalid(i.e. breaks connection of partition)
def eat_random_node(G: nx.Graph(), partition_node_list: list, debug_print_mode = False) -> (list, bool):
    if debug_print_mode:
        print('\n\n')
    is_eat_true = False
    is_node_list_changed = False
    return_list = []
    is_proper_partition_picked = False
    new_switched_partition_node_list = copy.deepcopy(partition_node_list.copy())  # make deep copy of node list

    # If partner partition has only one node repeat random picking process, should not eliminate partition altogether
    while True:
        random_partition_num = random.randint(0, len(partition_node_list) - 1)  # select random partition to switch from
        boundary_edge_list = nx_gen_object_to_list(
            nx.edge_boundary(G, partition_node_list[random_partition_num]))  # boundary edges of partition
        random_boundary_edge_pair_index = random.randint(0,
                                                         len(boundary_edge_list) - 1)  # first node is in current partition num second node is partner
        random_boundary_edge_pair = boundary_edge_list[random_boundary_edge_pair_index]
        # find partner partition to eat from
        partner_partition_num = 0
        # find partner partition number
        for kth_partition in new_switched_partition_node_list:
            if random_boundary_edge_pair[1] in kth_partition:
                break
            else:
                partner_partition_num = partner_partition_num + 1
        if (len(partition_node_list[partner_partition_num]) == 1):
            print("Remaining Node 1 Case Triggered")
            is_proper_partition_picked = False
        else:
            is_proper_partition_picked = True
        if (is_proper_partition_picked == True):
            break
        elif len(partition_node_list[random_partition_num]) == G.number_of_nodes() - (len(partition_node_list) - 1):
            print('Partition ' + str(random_partition_num) + ' has reached max size of ' + str(
                G.number_of_nodes() - (len(partition_node_list) - 1)))
            return partition_node_list, False
        else:
            pass

    #check if total len number remains constant
    random_part_original_len = len(new_switched_partition_node_list[random_partition_num])
    partner_part_original_len = len(new_switched_partition_node_list[partner_partition_num])
    # For some reason new_switched_partition_node_list[random_partition_num] is treated as numpy narray
    #print('Type;!')
    #print(type(new_switched_partition_node_list[random_partition_num]))
    # Use numpy functions instead of list when operating on this.
    if debug_print_mode:
        print('Boundary Edge: ', random_boundary_edge_pair)
        print('Original Random Partition: ', new_switched_partition_node_list[random_partition_num])
        print('Original Partner Partition: ', new_switched_partition_node_list[partner_partition_num])
        print('Partition Numbers (Random, Partner)', random_partition_num,partner_partition_num)
    # random_partition_num partition will eat the entirety of boundary edge pair nodes
    # index_loc_0 = np.where(new_switched_partition_node_list[random_partition_num] == random_boundary_edge_pair[0])
    index_loc_1 = np.where(new_switched_partition_node_list[partner_partition_num] == random_boundary_edge_pair[1])
    if debug_print_mode:
        print(index_loc_1)
    index_loc_1 = 0
    for ele in new_switched_partition_node_list[partner_partition_num]:
        if ele == random_boundary_edge_pair[1]:
            break
        else:
            index_loc_1 = index_loc_1 + 1

    if debug_print_mode:
        print(index_loc_1)
        print('Index Number of Edge Node in Partner Partition: ', index_loc_1)
    #print(len(index_loc_1))
    # delete from partner partition (random_boundary_edge_pair[1])
    new_switched_partition_node_list[partner_partition_num] = np.delete(
        new_switched_partition_node_list[partner_partition_num], index_loc_1)
    # add to random partition
    new_switched_partition_node_list[random_partition_num] = np.append(
        new_switched_partition_node_list[random_partition_num], random_boundary_edge_pair[1])
    # new_switched_partition_node_list[random_partition_num][index_loc_0], new_switched_partition_node_list[partner_partition_num][index_loc_1] = new_switched_partition_node_list[partner_partition_num][index_loc_1], new_switched_partition_node_list[random_partition_num][index_loc_0]
    if debug_print_mode:
        print('New Random Partition: ', new_switched_partition_node_list[random_partition_num])
        print('New Partner Partition: ', new_switched_partition_node_list[partner_partition_num])
    # Check if the new partitions are valid(they should be connected)
    part_0 = G.subgraph(new_switched_partition_node_list[random_partition_num])
    part_1 = G.subgraph(new_switched_partition_node_list[partner_partition_num])
    fst_part_connect_state = nx.is_connected(part_0)
    snd_part_connect_state = nx.is_connected(part_1)
    # Is length maintained?
    new_random_part_len = len(new_switched_partition_node_list[random_partition_num])
    new_partner_part_len = len(new_switched_partition_node_list[partner_partition_num])
    if debug_print_mode:
        print('Original Random Part Length: ', random_part_original_len)
        print('Original Partner Part Length: ', partner_part_original_len)
        print('New Random Part Length: ', new_random_part_len)
        print('New Partner Part Length: ', new_partner_part_len)
    if(new_random_part_len + new_partner_part_len == random_part_original_len + partner_part_original_len):
        is_len_valid = True
    else:
        is_len_valid = False
    new_switched_partition_node_list[random_partition_num].sort()
    new_switched_partition_node_list[partner_partition_num].sort()
    if np.array_equal(np.array(new_switched_partition_node_list, dtype=object),
                      np.array(partition_node_list, dtype=object)):
        is_node_list_changed = False
    else:
        is_node_list_changed = True
    if (fst_part_connect_state and snd_part_connect_state and is_node_list_changed and is_len_valid):  # is eating valid and actually happened
        is_eat_true = True
        return_list = new_switched_partition_node_list
    else:
        is_eat_true = False
        return_list = partition_node_list

    if debug_print_mode:
        if(is_eat_true):
            print('Eat Valid')
        else:
            print('Eat Invalid')
            print('1st Connect, 2nd Connect, List Change, Length Validity:', fst_part_connect_state, snd_part_connect_state, is_node_list_changed, is_len_valid)
    return return_list, is_eat_true


def DEBUG_FUNCTION_feed_partition_0(G: nx.Graph(), partition_node_list: list) -> (list, bool):
    is_eat_true = False
    is_node_list_changed = False
    return_list = []
    is_proper_partition_picked = False
    new_switched_partition_node_list = copy.deepcopy(partition_node_list.copy())  # make deep copy of node list

    # If partner partition has only one node repeat random picking process, should not eliminate partition altogether
    while True:
        # random_partition_num = random.randint(0,len(partition_node_list)-1) # select random partition to switch from
        random_partition_num = 0
        boundary_edge_list = nx_gen_object_to_list(
            nx.edge_boundary(G, partition_node_list[random_partition_num]))  # boundary edges of partition
        random_boundary_edge_pair_index = random.randint(0,
                                                         len(boundary_edge_list) - 1)  # first node is in current partition num second node is partner
        random_boundary_edge_pair = boundary_edge_list[random_boundary_edge_pair_index]
        print(random_boundary_edge_pair)
        # find partner partition to eat from
        partner_partition_num = 0
        # find partner partition number
        for kth_partition in new_switched_partition_node_list:
            if random_boundary_edge_pair[1] in kth_partition:
                break
            else:
                partner_partition_num = partner_partition_num + 1
        if (len(partition_node_list[partner_partition_num]) == 1):
            is_proper_partition_picked = False
        else:
            is_proper_partition_picked = True
        if (is_proper_partition_picked == True):
            break
        elif len(partition_node_list[random_partition_num]) == G.number_of_nodes() - (len(partition_node_list) - 1):
            print('Partition ' + str(random_partition_num) + ' has reached max size of ' + str(
                G.number_of_nodes() - (len(partition_node_list) - 1)))
            return partition_node_list, False
        else:
            pass

    # For some reason new_switched_partition_node_list[random_partition_num] is treated as numpy narray
    # Use numpy functions instead of list when operating on this.

    # random_partition_num partition will eat the entirety of boudary edge pair nodes
    # index_loc_0 = np.where(new_switched_partition_node_list[random_partition_num] == random_boundary_edge_pair[0])
    index_loc_1 = np.where(new_switched_partition_node_list[partner_partition_num] == random_boundary_edge_pair[1])
    # delete from partner partition (random_boundary_edge_pair[1])
    new_switched_partition_node_list[partner_partition_num] = np.delete(
        new_switched_partition_node_list[partner_partition_num], index_loc_1)
    # add to random partition
    new_switched_partition_node_list[random_partition_num] = np.append(
        new_switched_partition_node_list[random_partition_num], random_boundary_edge_pair[1])
    # new_switched_partition_node_list[random_partition_num][index_loc_0], new_switched_partition_node_list[partner_partition_num][index_loc_1] = new_switched_partition_node_list[partner_partition_num][index_loc_1], new_switched_partition_node_list[random_partition_num][index_loc_0]

    # Check if the new partitions are valided(they should be connected)
    part_0 = G.subgraph(new_switched_partition_node_list[random_partition_num])
    part_1 = G.subgraph(new_switched_partition_node_list[partner_partition_num])
    fst_part_connect_state = nx.is_connected(part_0)
    snd_part_connect_state = nx.is_connected(part_1)
    if np.array_equal(np.array(new_switched_partition_node_list, dtype=object),
                      np.array(partition_node_list, dtype=object)):
        is_node_list_changed = False
    else:
        is_node_list_changed = True
    if (
            fst_part_connect_state and snd_part_connect_state and is_node_list_changed):  # is switch valid and actually happened
        is_eat_true = True
        return_list = new_switched_partition_node_list
    else:
        is_eat_true = False
        return_list = partition_node_list
    return return_list, is_eat_true


def print_node_list(node_list):
    for line in node_list:
        print(line)


def get_color_map_from_dict(input_dict):
    output_list = []
    for i in range(len(input_dict)):
        output_list.extend([input_dict[i][Dict_Trait.color]])
    return output_list


# Calculate result of one district add the all the nodes up into tuple form result
# (partition_pop, partition_vote, partition_party_1_vote, partition_party_2_vote, district_winner, wasated_vote
# Output: (part_pop, part_vote, part_party_1_vote, part_party_2_vote, district_winner, party_1_wasted_vote, party_2_wasted_vote)
def calculate_part_result(G: nx.Graph, node_list: list):
    part_pop = 0
    part_vote = 0
    part_party_1_vote = 0
    part_party_2_vote = 0
    part_party_3_vote = 0
    district_winner = 0
    #wasted_vote = 0  # wasted vote by party1 is (+) while wasted vote by party2 is (-)
    party_1_wasted_vote = 0
    party_2_wasted_vote = 0
    for node_num in node_list:
        part_pop = part_pop + G.nodes[node_num][Dict_Trait.pop]
        part_vote = part_vote + G.nodes[node_num][Dict_Trait.total_votes]
        part_party_1_vote = part_party_1_vote + G.nodes[node_num][Dict_Trait.party_1]
        part_party_2_vote = part_party_2_vote + G.nodes[node_num][Dict_Trait.party_2]
        part_party_3_vote = part_party_3_vote + G.nodes[node_num][Dict_Trait.party_3]
    if part_party_1_vote > part_party_2_vote and part_party_1_vote > part_party_3_vote:
        district_winner = 1
        party_1_wasted_vote = max(part_party_1_vote-(int(part_vote/2)+1),0)
        party_2_wasted_vote = part_party_2_vote
        #wasted_vote = wasted_vote - part_party_2_vote
    elif part_party_2_vote > part_party_1_vote and part_party_2_vote > part_party_3_vote:
        district_winner = 2
        party_2_wasted_vote = max(part_party_2_vote-(int(part_vote/2)+1),0)
        party_1_wasted_vote = part_party_1_vote
        #wasted_vote = wasted_vote + part_party_1_vote
    elif part_party_3_vote > part_party_2_vote and part_party_3_vote > part_party_1_vote:
        district_winner = 3
        party_1_wasted_vote = part_party_1_vote
        party_2_wasted_vote = part_party_2_vote

    return (part_pop, part_vote, part_party_1_vote, part_party_2_vote, district_winner, party_1_wasted_vote, party_2_wasted_vote)


# Calculate election result of graph with the input partition configuration
# Output Total Population, Total Vote Count, Voting Share of Party1/2 ,Number of Districts Won by Party_1 and Party_2,
# Variation of Population, and Efficiency Gap
def calculate_graph_result(G: nx.Graph(), partition_node_list: list, print_district_by_district_result=False):
    iteration = 0
    graph_pop = 0
    graph_vote = 0
    graph_party_1_vote = 0
    graph_party_2_vote = 0
    party_1_district_won = 0
    party_2_district_won = 0
    party_3_district_won = 0
    pop_avg = 0.
    pop_variance = 0.
    party_1_wasted_vote = 0
    party_2_wasted_vote = 0
    graph_efficiency_gap = 0.  # party_1_wasted_vote-party_2_wasted_vote/graph_vote # (-) favors party1 (+) favors
    tied_districts = 0
    # party2
    part_result_list = []
    pop_list = []
    for part_list in partition_node_list:
        part_result_list.append(calculate_part_result(G, part_list))
        if (print_district_by_district_result):
            print('District #', iteration, 'Result')
            print_district_result(*(part_result_list[iteration]))
            print('\n')
            iteration = iteration + 1
    for tuples in part_result_list:
        graph_pop = graph_pop + tuples[0]
        pop_list.append(tuples[0])
        graph_vote = graph_vote + tuples[1]
        graph_party_1_vote = graph_party_1_vote + tuples[2]
        graph_party_2_vote = graph_party_2_vote + tuples[3]
        if (tuples[4] == 1):
            party_1_district_won = party_1_district_won + 1
        elif (tuples[4] == 2):
            party_2_district_won = party_2_district_won + 1
        elif (tuples[4] == 3):
            party_3_district_won = party_3_district_won + 1
        else:
            print('Ties')
            tied_districts = tied_districts + 1
            print(tuples)

        party_1_wasted_vote = party_1_wasted_vote + tuples[5]
        party_2_wasted_vote = party_2_wasted_vote + tuples[6]



    pop_avg = statistics.mean(pop_list)
    pop_variance = statistics.variance(pop_list)
    graph_efficiency_gap = ((party_1_wasted_vote - party_2_wasted_vote) / graph_vote) * 100  # percentage
    return (graph_pop, graph_vote, graph_party_1_vote, graph_party_2_vote, party_1_district_won, party_2_district_won,
            party_3_district_won, pop_avg, pop_variance, party_1_wasted_vote, party_2_wasted_vote, graph_efficiency_gap,tied_districts)


def print_district_result(part_pop, part_vote, part_party_1_vote, part_party_2_vote, district_winner, party_1_wasted_vote, party_2_wasted_vote):
    percentage1 = (part_party_1_vote / part_vote) * 100
    percentage2 = (part_party_2_vote / part_vote) * 100
    print('District Result')
    print('Total District Population: ', part_pop)
    print('Total Vote: ', part_vote)
    print('Total Party1 Vote: ', part_party_1_vote, ' (', percentage1, '%)')
    print('Total Party2 Vote: ', part_party_2_vote, ' (', percentage2, '%)')
    print('District Winner: ', district_winner)
    print('Party 1 Wasted Votes: ', party_1_wasted_vote)
    print('Party 2 Wasted Votes: ', party_2_wasted_vote)


def print_graph_result(graph_pop, graph_vote, graph_party_1_vote, graph_party_2_vote, party_1_district_won,
                       party_2_district_won, party_3_district_won, pop_avg, pop_variance, party_1_wasted_vote,
                       party_2_wasted_vote, graph_efficiency_gap,tied_districts):
    percentage1 = (graph_party_1_vote / graph_vote) * 100
    percentage2 = (graph_party_2_vote / graph_vote) * 100
    print('Graph(Province) Result')
    print('Total Graph(Province) Population: ', graph_pop)
    print('Average Graph(Province) Population: ', pop_avg)
    print('Variance of Graph(Province) Population: ', pop_variance)
    print('Total Vote: ', graph_vote)
    print('Total Party1 Vote: ', graph_party_1_vote, ' (', percentage1, '%)')
    print('Total Party2 Vote: ', graph_party_2_vote, ' (', percentage2, '%)')
    print('Party1 Districts: ', party_1_district_won)
    print('Party2 Districts: ', party_2_district_won)
    print('Party3 Districts: ', party_3_district_won)
    print('Tied Districts: ', tied_districts)
    print('Party1 Wasted Votes: ', party_1_wasted_vote)
    print('Party2 Wasted Votes: ', party_2_wasted_vote)
    print('Efficiency Gap: ', graph_efficiency_gap, '(%) (Negative values favor Party1 while positive values favor '
                                                    'Party2.)')


# Run eat_random_node() to generate next state and compare between current and next states.
# If computed score is better adopt next state if not only adopt with probability of exp(score_diff/Temp)
# Output either input list(if no change) or changed list
# Use for Monte CArlo Simulated Annealing Algorithm
def anneal_step(G: nx.Graph(), current_part_state: list, current_state_score: float, current_temp: float) -> list:
    next_part_state,eat_validity = eat_random_node(G, current_part_state)
    next_state_score = compute_state_score(G, next_part_state)
    score_delta = next_state_score - current_state_score

    if(score_delta > 0): #next state is improvement
        output_state = next_part_state
        output_score = next_state_score

        print('\n')
        print('State Improved')
        print('Temperature: ', current_temp)
        print('Current Score: ', current_state_score)
        print('Next Score: ', next_state_score)
        print('\n')
    else: #next state is not an improvement
        probability = math.exp(score_delta/current_temp)
        if(random.random() <probability): #move to next state even if it is worst under probability
            output_state = next_part_state
            output_score = next_state_score
            print('\n')
            print('State Not Improved Move Anyway', probability)
            print('Temperature: ', current_temp)
            print('Current Score: ', current_state_score)
            print('Next Score: ', next_state_score)
            print('Probability: ', probability)
            print('\n')
        else:
            output_state = current_part_state
            output_score = current_state_score
            print('\n')
            print('State Not Improved Do Not Move')
            print('Temperature: ', current_temp)
            print('Current Score: ', current_state_score)
            print('Next Score: ', next_state_score)
            print('Probability: ', probability)
            print('\n')
    return output_state,output_score

def compute_state_score(G: nx.Graph(), state_part_list: list, pop_distribute_weight = 0.8) -> float:
    (efficiency_gap ,pop_variance) = (0,0)
    (_, _, _, _, _, _, _, pop_avg, pop_variance, _, _, graph_efficiency_gap,_) = calculate_graph_result(G,state_part_list)
    pop_portion = 100*(1-math.exp(-(pop_variance/(9*pop_avg)))) * pop_distribute_weight
    partisan_portion = efficiency_gap * (1-pop_distribute_weight)
    val = 5000*math.exp(-0.131*(pop_portion+partisan_portion))
    #val = max((pop_variance + abs(graph_efficiency_gap)),0.1) #simple placeholder function
    #val = 100/val
    return val

def graph_simulated_annealing(G: nx.Graph(), partition_node_list, step_size = 100):
    result_list = []
    initial_score = compute_state_score(G,partition_node_list)
    start_temp = 10000 # Temperature always starts at 10000
    epoch_num = int(start_temp/step_size)
    # temp function Temp = 1000/(time^alpha + 1) (T:10000 ->0.01 as time goes on)
    alpha = 6/(math.log10(epoch_num))
    result_list,score = anneal_step(G,partition_node_list,initial_score,start_temp)
    for time in range(epoch_num):
        current_temp = start_temp/((time**alpha) + 1)
        result_list, score = anneal_step(G, result_list, score, current_temp)
        #result_list,score = anneal_step(G, result_list, score,start_temp-step_size*time)
    return result_list

Dict_format = dict(
    {'name': 'default', 'id': 0, 'pop': 0, 'total_votes': 0, 'party_1': 0, 'party_2': 0, 'color': 'white'})
Dict_example = dict(
    {Dict_Trait.name: 'default', Dict_Trait.id: 0, Dict_Trait.pop: 0, Dict_Trait.total_votes: 0, Dict_Trait.party_1: 0,
     Dict_Trait.party_2: 0, Dict_Trait.party_3: 0, Dict_Trait.color: 'white'})

key_list = []
n = 5
m = 10
G = nxm_rectangle_graph_gen(n, m)
for x in range(G.number_of_nodes()):
    key_list.append(x)

value_list = []
for i in range(G.number_of_nodes()):
    dict_element_1 = {Dict_Trait.name: 'default', Dict_Trait.id: 0, Dict_Trait.pop: 10, Dict_Trait.total_votes: 10,
                      Dict_Trait.party_1: 10, Dict_Trait.party_2: 0, Dict_Trait.party_3: 0, Dict_Trait.color: 'blue'}
    dict_element_2 = {Dict_Trait.name: 'default', Dict_Trait.id: 0, Dict_Trait.pop: 10, Dict_Trait.total_votes: 10,
                      Dict_Trait.party_1: 0, Dict_Trait.party_2: 10, Dict_Trait.party_3: 0, Dict_Trait.color: 'yellow'}
    if i % n > 1:
        dict_element_1[Dict_Trait.id] = i
        value_list.append(dict_element_1)
    else:
        dict_element_2[Dict_Trait.id] = i
        value_list.append(dict_element_2)

node_dict = {key_list[i]: value_list[i] for i in range(len(key_list))}
nx.set_node_attributes(G, node_dict)

# layout = nx.planar_layout(G)
color_map = get_color_map_from_dict(node_dict)
nx.draw(G, with_labels=True, node_color=color_map)
plt.show()
print_district_result(*(calculate_part_result(G, [0, 1, 2, 3, 4])))
partition_node_list = gen_init_part(G, 5)
print_node_list(partition_node_list)
print_graph_result(*(calculate_graph_result(G, partition_node_list, True)))

# Test configuration taken from (https://en.wikipedia.org/wiki/Gerrymandering#/media/File:DifferingApportionment.svg)
config1 = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
           [10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
           [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
           [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],
           [40, 41, 42, 43, 44, 45, 46, 47, 48, 49]]
config2 = [[0, 5, 6, 7, 8, 10, 11, 12, 13, 15],
           [16, 17, 18, 20, 21, 25, 26, 31, 32, 33],
           [30, 35, 36, 37, 38, 40, 41, 42, 43, 45],
           [1, 2, 3, 4, 9, 14, 19, 24, 23, 22],
           [27, 28, 29, 34, 39, 44, 46, 47, 48, 49]]
config3 = [[0, 5, 10, 15, 20, 25, 30, 35, 40, 45],
           [1, 6, 11, 16, 21, 26, 31, 36, 41, 46],
           [2, 7, 12, 17, 22, 27, 32, 37, 42, 47],
           [3, 8, 13, 18, 23, 28, 33, 38, 43, 48],
           [4, 9, 14, 19, 24, 29, 34, 39, 44, 49]]
config4 = [[0, 1, 2, 3, 4, 7, 8, 9, 13, 14],
           [5, 6, 10, 11, 12, 15, 16, 17, 18, 19],
           [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
           [30, 31, 32, 33, 34, 37, 38, 39, 43, 44],
           [35, 36, 40, 41, 42, 45, 46, 47, 48, 49]]
print_district_by_district_result = False
print('\nConfig1\n')
print_graph_result(*(calculate_graph_result(G, config1, print_district_by_district_result)))
print('\nConfig2\n')
print_graph_result(*(calculate_graph_result(G, config2, print_district_by_district_result)))
print('\nConfig3\n')
print_graph_result(*(calculate_graph_result(G, config3, print_district_by_district_result)))
print('\nConfig4\n')
print_graph_result(*(calculate_graph_result(G, config4, print_district_by_district_result)))

config1_test = list(set().union(config1[0], config1[1], config1[2], config1[3], config1[4]))
config2_test = list(set().union(config2[0], config2[1], config2[2], config2[3], config2[4]))
config3_test = list(set().union(config3[0], config3[1], config3[2], config3[3], config3[4]))
config4_test = list(set().union(config4[0], config4[1], config4[2], config4[3], config4[4]))
print(config1_test)
print(config2_test)
print(config3_test)
print(config4_test)
print(len(config1_test),
      len(config2_test),
      len(config3_test),
      len(config4_test))
# G.add_nodes_from([(0,{})])
# nx.set_node_attributes(G,Dict_format)
print('Initial Config1 before iteration:')
print(print_graph_result(*(calculate_graph_result(G,config1, print_district_by_district_result))))

input = config1
initial_score = compute_state_score(G,input)
print('Initial Score: ', initial_score)
result,score = anneal_step(G, config1, initial_score, 1000)
print(print_graph_result(*(calculate_graph_result(G,result, print_district_by_district_result))))
print('Score Start: ', score)

result, bool_val = eat_random_node(G,config1)
flip_num = 0
for x in range(10):
    result, bool_val = eat_random_node(G,result)
    if(bool_val):
        flip_num = flip_num + 1
    if (x %1000 == 0):
        print(len(result[0]) + len(result[1]) + len(result[2]) + len(result[3]) + len(result[4]))

print_node_list(result)
print(len(result[0])+len(result[1])+len(result[2])+len(result[3])+len(result[4]))
new_result = []
for l in result:
    new_result.extend(l)
new_result.sort()
print(new_result)
print('Eat Operation Num: ',flip_num)



print('Initial Config1 before iteration:')
print(print_graph_result(*(calculate_graph_result(G,config1, print_district_by_district_result))))

input = config1
initial_score = compute_state_score(G,input)
print('Initial Score: ', initial_score)
result,score = anneal_step(G, config1, initial_score, 1000)
print(print_graph_result(*(calculate_graph_result(G,result, print_district_by_district_result))))
print('Score Start: ', score)

for x in range(1000):
    result,score =  anneal_step(G,result, score,1000-x)
    if(x %100 == 0):
        print('Epoch: ', x)
        print(result)
        print(print_graph_result(*(calculate_graph_result(G, result, print_district_by_district_result))))
        l = list(set().union(result[0], result[1], result[2], result[3], result[4]))
        print(l, len(l))
        print('Current Score: ',score)

l = list(set().union(result[0],result[1],result[2],result[3],result[4]))
print(l, len(l))
print(print_graph_result(*(calculate_graph_result(G,result, print_district_by_district_result))))
print('Score Final:', score)
print_node_list(result)

result_example = [[ 0,  1,  2,  3,  4,  5,  6,  8,  9, 10],
            [ 7, 11, 12, 13, 14, 18, 19, 23, 24, 29],
            [15, 16, 17, 20, 21, 22, 25, 26, 27, 32],
            [30, 31, 35, 36, 40, 41, 42, 43, 45, 46],
            [28, 33, 34, 37, 38, 39, 44, 47, 48, 49]
            ]
print(print_graph_result(*(calculate_graph_result(G,result_example, print_district_by_district_result))))
for line in result_example:
    print(nx.is_connected(G.subgraph(line)))

init_part = gen_init_part(G,5)
print_node_list(init_part)
l = graph_simulated_annealing(G,init_part)
print(print_graph_result(*(calculate_graph_result(G,l, print_district_by_district_result))))
print_node_list(l)
print_node_list(init_part)


#Sejong Demo:
#described in sejong.adjlist
#Consists of 22 nodes and 2 districts
temp_G = nx.Graph()
adj_list_path = 'sejong.adjlist'
temp_G = nx.read_adjlist(adj_list_path)
temp_adj_list = nx_gen_object_to_list(nx.generate_adjlist(temp_G))
print(temp_adj_list)
print(temp_adj_list[0].split(' '))
Sejong_G_edge_list = []
for x in range(len(temp_adj_list)):
    #print(type(line))
    list_ = temp_adj_list[x].split(' ')
    list_ = [int(i) for i in list_]
    ele_list = []
    for y in range(1,len(list_)):
        ele_list.append((list_[0], list_[y]))
    Sejong_G_edge_list.extend(ele_list)

    #list_ = [int(i) for i in line.split(' ')]
    #list_.pop(0)
    #temp_adj_list.append(list_)
#print(temp_adj_list)
print(Sejong_G_edge_list)
Sejong_G = nx.Graph()
Sejong_G.add_edges_from(Sejong_G_edge_list)
print(Sejong_G.number_of_nodes())



sejong_3611055000 =dict({Dict_Trait.name: '고운동', Dict_Trait.id: 3611055000, Dict_Trait.pop: 34104, Dict_Trait.total_votes: 15230, Dict_Trait.party_1: 8489, Dict_Trait.party_2: 6058, Dict_Trait.party_3: 452, Dict_Trait.color: 'white'})
sejong_3611034000 =dict({Dict_Trait.name: '금남면', Dict_Trait.id: 3611034000, Dict_Trait.pop: 8917, Dict_Trait.total_votes: 5422, Dict_Trait.party_1: 2131, Dict_Trait.party_2: 3050, Dict_Trait.party_3: 127, Dict_Trait.color: 'white'})
sejong_3611058000 =dict({Dict_Trait.name: '다정동', Dict_Trait.id: 3611058000, Dict_Trait.pop: 28226, Dict_Trait.total_votes: 14980, Dict_Trait.party_1: 8046, Dict_Trait.party_2: 6199, Dict_Trait.party_3: 503, Dict_Trait.color: 'white'})
sejong_3611057000 =dict({Dict_Trait.name: '대평동', Dict_Trait.id: 3611057000, Dict_Trait.pop: 11316, Dict_Trait.total_votes: 6768, Dict_Trait.party_1: 3497, Dict_Trait.party_2: 2972, Dict_Trait.party_3: 206, Dict_Trait.color: 'white'})
sejong_3611052000 =dict({Dict_Trait.name: '도담동', Dict_Trait.id: 3611052000, Dict_Trait.pop: 33520, Dict_Trait.total_votes: 16618, Dict_Trait.party_1: 8589, Dict_Trait.party_2: 7238, Dict_Trait.party_3: 535, Dict_Trait.color: 'white'})
sejong_3611055600 =dict({Dict_Trait.name: '반곡동', Dict_Trait.id: 3611055600, Dict_Trait.pop: 22210, Dict_Trait.total_votes: 10594, Dict_Trait.party_1: 5631, Dict_Trait.party_2: 4415, Dict_Trait.party_3: 363, Dict_Trait.color: 'white'})
sejong_3611056000 =dict({Dict_Trait.name: '보람동', Dict_Trait.id: 3611056000, Dict_Trait.pop: 18852, Dict_Trait.total_votes: 10415, Dict_Trait.party_1: 5632, Dict_Trait.party_2: 4295, Dict_Trait.party_3: 330, Dict_Trait.color: 'white'})
sejong_3611033000 =dict({Dict_Trait.name: '부강면', Dict_Trait.id: 3611033000, Dict_Trait.pop: 6090, Dict_Trait.total_votes: 3881, Dict_Trait.party_1: 1719, Dict_Trait.party_2: 1968, Dict_Trait.party_3: 92, Dict_Trait.color: 'white'})
sejong_3611051500 =dict({Dict_Trait.name: '새롬동', Dict_Trait.id: 3611051500, Dict_Trait.pop: 39069, Dict_Trait.total_votes: 18210, Dict_Trait.party_1: 9557, Dict_Trait.party_2: 7854, Dict_Trait.party_3: 545, Dict_Trait.color: 'white'})
sejong_3611055500 =dict({Dict_Trait.name: '소담동', Dict_Trait.id: 3611055500, Dict_Trait.pop: 21004, Dict_Trait.total_votes: 10787, Dict_Trait.party_1: 5926, Dict_Trait.party_2: 4392, Dict_Trait.party_3: 320, Dict_Trait.color: 'white'})
sejong_3611039000 =dict({Dict_Trait.name: '소정면', Dict_Trait.id: 3611039000, Dict_Trait.pop: 2229, Dict_Trait.total_votes: 1374, Dict_Trait.party_1: 496, Dict_Trait.party_2: 810, Dict_Trait.party_3: 37, Dict_Trait.color: 'white'})
sejong_3611053000 =dict({Dict_Trait.name: '아름동', Dict_Trait.id: 3611053000, Dict_Trait.pop: 23291, Dict_Trait.total_votes: 12542, Dict_Trait.party_1: 7361, Dict_Trait.party_2: 4594, Dict_Trait.party_3: 433, Dict_Trait.color: 'white'})
sejong_3611031000 =dict({Dict_Trait.name: '연기면', Dict_Trait.id: 3611031000, Dict_Trait.pop: 2780, Dict_Trait.total_votes: 2819, Dict_Trait.party_1: 1349, Dict_Trait.party_2: 1346, Dict_Trait.party_3: 63, Dict_Trait.color: 'white'})
sejong_3611032000 =dict({Dict_Trait.name: '연동면', Dict_Trait.id: 3611032000, Dict_Trait.pop: 3086, Dict_Trait.total_votes: 1993, Dict_Trait.party_1: 728, Dict_Trait.party_2: 1181, Dict_Trait.party_3: 34, Dict_Trait.color: 'white'})
sejong_3611036000 =dict({Dict_Trait.name: '연서면', Dict_Trait.id: 3611036000, Dict_Trait.pop: 7336, Dict_Trait.total_votes: 5581, Dict_Trait.party_1: 2620, Dict_Trait.party_2: 2737, Dict_Trait.party_3: 101, Dict_Trait.color: 'white'})
sejong_3611035000 =dict({Dict_Trait.name: '장군면', Dict_Trait.id: 3611035000, Dict_Trait.pop: 7057, Dict_Trait.total_votes: 3931, Dict_Trait.party_1: 1796, Dict_Trait.party_2: 1974, Dict_Trait.party_3: 73, Dict_Trait.color: 'white'})
sejong_3611038000 =dict({Dict_Trait.name: '전동면', Dict_Trait.id: 3611038000, Dict_Trait.pop: 3359, Dict_Trait.total_votes: 1981, Dict_Trait.party_1: 731, Dict_Trait.party_2: 1161, Dict_Trait.party_3: 46, Dict_Trait.color: 'white'})
sejong_3611037000 =dict({Dict_Trait.name: '전의면', Dict_Trait.id: 3611037000, Dict_Trait.pop: 5524, Dict_Trait.total_votes: 3452, Dict_Trait.party_1: 1368, Dict_Trait.party_2: 1909, Dict_Trait.party_3: 87, Dict_Trait.color: 'white'})
sejong_3611025000 =dict({Dict_Trait.name: '조치원읍', Dict_Trait.id: 3611025000, Dict_Trait.pop: 43191, Dict_Trait.total_votes: 20910, Dict_Trait.party_1: 9666, Dict_Trait.party_2: 10152, Dict_Trait.party_3: 576, Dict_Trait.color: 'white'})
sejong_3611054000 =dict({Dict_Trait.name: '종촌동', Dict_Trait.id: 3611054000, Dict_Trait.pop: 28948, Dict_Trait.total_votes: 15674, Dict_Trait.party_1: 8662, Dict_Trait.party_2: 6362, Dict_Trait.party_3: 445, Dict_Trait.color: 'white'})
sejong_3611051000 =dict({Dict_Trait.name: '한솔동', Dict_Trait.id: 3611051000, Dict_Trait.pop: 18546, Dict_Trait.total_votes: 10184, Dict_Trait.party_1: 5599, Dict_Trait.party_2: 4140, Dict_Trait.party_3: 311, Dict_Trait.color: 'white'})
sejong_3611052500 =dict({Dict_Trait.name: '해밀동', Dict_Trait.id: 3611052500, Dict_Trait.pop: 8641, Dict_Trait.total_votes: 4589, Dict_Trait.party_1: 2670, Dict_Trait.party_2: 1726, Dict_Trait.party_3: 140, Dict_Trait.color: 'white'})



'''
3611010100	3611031000 3611034000 3611010200 3611032000
3611010200	3611031000 3611010100 3611034000 3611010300
3611010300	3611031000 3611010200 3611034000 3611010400
3611010400	3611031000 3611010300 3611034000
3611010600	3611010800 3611031000 3611035000 3611010800
3611010800	3611035000 3611010900 3611010600 3611010600 3611011400 3611031000
3611010900	3611011200 3611011100 3611011400 3611010800 3611010800 3611035000
3611011100	3611011200 3611011300 3611011400 3611011400 3611010900
3611011200	3611031000 3611011600 3611011300 3611011100 3611010900 3611035000
3611011300	3611011200 3611011600 3611011400 3611011100
3611011400	3611011600 3611011600 3611031000 3611011100 3611011300 3611010800 3611010900
3611011600	3611031000 3611011400 3611011300 3611011200
3611025000	3611038000 3611036000 3611032000
3611031000	3611036000 3611032000 3611010100 3611010100 3611010100
3611032000	3611025000 3611036000 3611031000 3611010100 3611034000 3611033000
3611033000	3611032000 3611034000
3611034000	3611035000 3611031000 3611010400 3611010300 3611010200 3611010100 3611010100 3611032000 3611033000
3611035000	3611036000 3611031000 3611011200 3611010900 3611010800 3611010600 3611034000
3611036000	3611037000 3611038000 3611025000 3611032000 3611031000 3611035000
3611037000	3611038000 3611036000
3611038000	3611037000 3611036000 3611025000
3611039000	3611037000
'''



sejong_key_list = [3611055000,
3611034000,
3611058000,
3611057000,
3611052000,
3611055600,
3611056000,
3611033000,
3611051500,
3611055500,
3611039000,
3611053000,
3611031000,
3611032000,
3611036000,
3611035000,
3611038000,
3611037000,
3611025000,
3611054000,
3611051000,
3611052500,
]
sejong_value_list = [sejong_3611055000,
sejong_3611034000,
sejong_3611058000,
sejong_3611057000,
sejong_3611052000,
sejong_3611055600,
sejong_3611056000,
sejong_3611033000,
sejong_3611051500,
sejong_3611055500,
sejong_3611039000,
sejong_3611053000,
sejong_3611031000,
sejong_3611032000,
sejong_3611036000,
sejong_3611035000,
sejong_3611038000,
sejong_3611037000,
sejong_3611025000,
sejong_3611054000,
sejong_3611051000,
sejong_3611052500
]

sejong_dict = {sejong_key_list[i]: sejong_value_list[i] for i in range(len(sejong_key_list))}
print(len(sejong_dict))
print((sejong_dict))
print(Sejong_G.nodes())
print('dict')
for item in sejong_dict:
    print(sejong_dict[item])

#node_dict = {key_list[i]: value_list[i] for i in range(len(key_list))}
nx.set_node_attributes(Sejong_G, sejong_dict)
#pos_Sejong_G = nx.spring_layout(Sejong_G)
nx.draw(Sejong_G, with_labels=True)
plt.show()
print('\n')
print(list(Sejong_G.nodes(data=Dict_Trait.name)))



'''
3611055000	고운동	34,104	15,230	8,489	6,058	452
3611034000	금남면	8,917	5,422	2,131	3,050	127
3611058000	다정동	28,226	14,980	8,046	6,199	503
3611057000	대평동	11,316	6,768	3,497	2,972	206
3611052000	도담동	33,520	16,618	8,589	7,238	535
3611055600	반곡동	22,210	10,594	5,631	4,415	363
3611056000	보람동	18,852	10,415	5,632	4,295	330
3611033000	부강면	6,090	3,881	1,719	1,968	92
3611051500	새롬동	39,069	18,210	9,557	7,854	545
3611055500	소담동	21,004	10,787	5,926	4,392	320
3611039000	소정면	2,229	1,374	496	810	37
3611053000	아름동	23,291	12,542	7,361	4,594	433
3611031000	연기면	2,780	2,819	1,349	1,346	63
3611032000	연동면	3,086	1,993	728	1,181	34
3611036000	연서면	7,336	5,581	2,620	2,737	101
3611035000	장군면	7,057	3,931	1,796	1,974	73
3611038000	전동면	3,359	1,981	731	1,161	46
3611037000	전의면	5,524	3,452	1,368	1,909	87
3611025000	조치원읍	43,191	20,910	9,666	10,152	576
3611054000	종촌동	28,948	15,674	8,662	6,362	445
3611051000	한솔동	18,546	10,184	5,599	4,140	311
3611052500	해밀동	8,641	4,589	2,670	1,726	140
'''
