import networkx as nx
from networkx.algorithms import community
import matplotlib.pyplot as plt
import pymetis
import numpy as np
import random
import bisect

'''
#General Algorithm
#1: Take G(original whole graph) and partition it into n contiguous proto-districts
#2: Gather all boundary connected components into set B(or lists of partition straddling edges)
#3: Select random node from B and switch with adjacent partition (check if the switch is valid)
 \ does not break up partitions repeat switch with new node if invalid (use nx.is_connected())
#4: Compute score for updated(pop/partisan lean/etc.) district config
#5 If new map is better keep changes
 \ If not, accept it anyway with probability R(to be determiend by exp(-kt/T), MonteCarlo Annealing
#6: Repeat process for certain amount of epoch until district configuration is optimized
'''

class Precint:
    def __init__(self, name = "default", id = 0, pop = 0, votes = 0, party_1 = 0, party_2 = 0):
        self.name = name
        self.id = id
        self.pop = pop
        self.votes = votes
        self.party_1 = party_1
        self.party_2 = party_2

test = Precint("test")
#Implement Graph Partition

#Generates square graph used for testing
def nxn_square_graph_gen(n):
    G = nx.Graph()
    for i in range(n**2):
        G.add_node(i)
    edge_list = []
    for j in range(n**2-1):
        if (j % n) == (n-1) and j < n*(n-1):
            edge_list.extend([(j,j+n)])
        elif j >= n*(n-1):
            edge_list.extend([(j,j+1)])
        else:
            edge_list.extend([(j,j+1),(j,j+n)])
    G.add_edges_from(edge_list)
    return G

#Used to convert adj_list generated by networkx into something pymetis can use to generate partition
def adj_list_to_metislist(adj_list):
    list_temp = []
    for line in adj_list:
        list_ = [int(i) for i in line.split(' ')]
        list_.pop(0)
        list_temp.append(list_)
    return list_temp


#Used to convert adj_lists (which is generator class) from networkx into python lists
def nx_gen_object_to_list(gen_object):
    list_temp = []
    for line in gen_object:
        list_ = [line]
        list_temp.extend(list_)
    return list_temp


def return_adj_list_of_graph(G: nx.Graph()) -> list:
    return_list = []
    for node in G.nodes():
        return_list.append([n for n in G.neighbors(node)])
    return return_list

#Take graph (G) and split it into n partitions return list containing lists of partition nodes
def gen_init_part(G: nx.Graph(), n: int) -> list:
    partition_node_list = []
    adj_list = return_adj_list_of_graph(G)
    n_cuts, membership = pymetis.part_graph(n, adjacency=adj_list)
    print(n_cuts)
    print(membership)
    nodes_part_0 = np.argwhere(np.array(membership) == 0).ravel()
    print(nodes_part_0)
    for i in range(n):
        print(i)
        node_temp_list = []
        node_temp_list = np.argwhere(np.array(membership) == i).ravel() #taken from
        # \https://github.com/inducer/pymetis#readme
        #print(node_temp_list)
        partition_node_list.append(node_temp_list)
    return partition_node_list

#Take graph (G) and partion node list and return switch one node from one partition to neighboring partition when valid
# select another node randomly if switch turns out to be invalid(i.e. breaks connection of partition)
def random_switch(G: nx.Graph(), partition_node_list: list) -> list:
    while True:
        new_switched_partition_node_list = partition_node_list.copy() # make full copy of node list
        random_partition_num = random.randint(0,len(partition_node_list)-1) # select random partition to switch from
        boundary_edge_list = nx.edge_boundary(G, partition_node_list[random_partition_num]) # boundary edges of partition
        random_boundary_edge_pair = random.randint(0,len(boundary_edge_list)-1) # first node is in current partition num second node is partner
        #find partner partition to switch to
        partner_partition_num = 0
        for kth_partition in new_switched_partition_node_list:
            if random_boundary_edge_pair[1] in kth_partition:
                break
            else:
                partner_partition_num = partner_partition_num + 1
        #switch between the two random_boundary_edge_pair nodes
        new_switched_partition_node_list[random_partition_num].remove(random_boundary_edge_pair[0])
        bisect.insort(new_switched_partition_node_list[random_partition_num], random_boundary_edge_pair[1]) # used bisect as list is already sorted
        new_switched_partition_node_list[partner_partition_num].remove(random_boundary_edge_pair[1])
        bisect.insort(new_switched_partition_node_list[partner_partition_num], random_boundary_edge_pair[0])

        #Check if the new partitions are valided(they should be connected)
        part_0 = G.subgraph(new_switched_partition_node_list[random_partition_num])
        part_1 = G.subgraph(new_switched_partition_node_list[partner_partition_num])
        fst_part_connect_state = nx.is_connected(part_0)
        snd_part_connect_state = nx.is_connected(part_1)
        if(fst_part_connect_state and snd_part_connect_state): # if both connect state is true (when partition is still connected)
            break   #exit loop
    return new_switched_partition_node_list


H = nxn_square_graph_gen(5)


adj_list = nx.generate_adjlist(H)

t = adj_list_to_metislist(adj_list)


n_cuts, membership = pymetis.part_graph(2, adjacency=t)
nodes_part_0 = np.argwhere(np.array(membership) == 0).ravel() # [3, 5, 6]
nodes_part_1 = np.argwhere(np.array(membership) == 1).ravel() # [0, 1, 2, 4]

nodes_part_0 = np.argwhere(np.array(membership) == 0).ravel() # [3, 5, 6]
nodes_part_1 = np.argwhere(np.array(membership) == 1).ravel() # [0, 1, 2, 4]
H_0 = H.subgraph(nodes_part_0)

nx.draw(H_0,with_labels=True)

plt.show()
H_0_boundary = nx.edge_boundary(H,nodes_part_0)
print(nx_gen_object_to_list(H_0_boundary))

H_1 = H.subgraph(nodes_part_1)
nx.draw(H_1, with_labels=True)
plt.show()
H_1_boundary = nx.edge_boundary(H,nodes_part_1)
print(nx_gen_object_to_list(H_1_boundary))

# nx.read_shp('emd.shp')
