import networkx as nx
from networkx.algorithms import community
import matplotlib.pyplot as plt
import pymetis
import numpy as np

'''
#General Algorithm
#1: Take G(original whole graph) and partition it into n contiguous proto-districts
#2: Gather all boundary connected components into set B(or lists of partition straddling edges)
#3: Select random node from B and switch with adjacent partition (check if the switch is valid)
 \ does not break up partitions repeat switch with new node if invalid (use nx.is_connected())
#4: Compute score for updated(pop/partisan lean/etc.) district config
#5 If new map is better keep changes
 \ If not, accept it anyway with probability R(to be determiend by exp(-kt/T), MonteCarlo Annealing
#6: Repeat process for certain amount of epoch until district configuration is optimized
'''

class Precint:
    def __init__(self, name = "default", id = 0, pop = 0, votes = 0, party_1 = 0, party_2 = 0):
        self.name = name
        self.id = id
        self.pop = pop
        self.votes = votes
        self.party_1 = party_1
        self.party_2 = party_2

test = Precint("test")
#Implement Graph Partition

#Generates square graph used for testing
def nxn_square_graph_gen(n):
    G = nx.Graph()
    for i in range(n**2):
        G.add_node(i)
    edge_list = []
    for j in range(n**2-1):
        if (j % n) == (n-1) and j < n*(n-1):
            edge_list.extend([(j,j+n)])
        elif j >= n*(n-1):
            edge_list.extend([(j,j+1)])
        else:
            edge_list.extend([(j,j+1),(j,j+n)])
    G.add_edges_from(edge_list)
    return G

#Used to convert adj_list generated by networkx into something pymetis can use to generate partition
def adj_list_to_metislist(adj_list):
    list_temp = []
    for line in adj_list:
        list_ = [int(i) for i in line.split(' ')]
        list_.pop(0)
        list_temp.append(list_)
    return list_temp


#Used to convert adj_lists (which is generator class) from networkx into python lists
def nx_gen_object_to_list(gen_object):
    list_temp = []
    for line in gen_object:
        list_ = [line]
        list_temp.extend(list_)
    return list_temp


def return_adj_list_of_graph(G: nx.Graph()) -> list:
    return_list = []
    for node in G.nodes():
        return_list.append([n for n in G.neighbors(node)])
    return return_list

#Take graph (G) and split it into n partitions return list containing lists of partition nodes
def gen_init_part(G: nx.Graph(), n: int) -> list:
    partition_node_list = []
    adj_list = return_adj_list_of_graph(G)
    n_cuts, membership = pymetis.part_graph(n, adjacency=adj_list)
    print(n_cuts)
    print(membership)
    nodes_part_0 = np.argwhere(np.array(membership) == 0).ravel()
    print(nodes_part_0)
    for i in range(n):
        print(i)
        node_temp_list = []
        node_temp_list = np.argwhere(np.array(membership) == i).ravel() #taken from
        # \https://github.com/inducer/pymetis#readme
        #print(node_temp_list)
        partition_node_list.append(node_temp_list)
    return partition_node_list


H = nxn_square_graph_gen(5)


adj_list = nx.generate_adjlist(H)

t = adj_list_to_metislist(adj_list)


n_cuts, membership = pymetis.part_graph(2, adjacency=t)
nodes_part_0 = np.argwhere(np.array(membership) == 0).ravel() # [3, 5, 6]
nodes_part_1 = np.argwhere(np.array(membership) == 1).ravel() # [0, 1, 2, 4]

nodes_part_0 = np.argwhere(np.array(membership) == 0).ravel() # [3, 5, 6]
nodes_part_1 = np.argwhere(np.array(membership) == 1).ravel() # [0, 1, 2, 4]
H_0 = H.subgraph(nodes_part_0)

nx.draw(H_0,with_labels=True)

plt.show()
H_0_boundary = nx.edge_boundary(H,nodes_part_0)
print(nx_gen_object_to_list(H_0_boundary))

H_1 = H.subgraph(nodes_part_1)
nx.draw(H_1, with_labels=True)
plt.show()
H_1_boundary = nx.edge_boundary(H,nodes_part_1)
print(nx_gen_object_to_list(H_1_boundary))

# nx.read_shp('emd.shp')
