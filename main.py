#Test eat_random_node function
import networkx as nx
from networkx.algorithms import community
import matplotlib.pyplot as plt
import pymetis
import numpy as np
import random
import copy

'''
#General Algorithm
#1: Take G(original whole graph) and partition it into n contiguous proto-districts
#2: Gather all boundary connected components into set B(or lists of partition straddling edges)
#3: Select random node from B and switch with adjacent partition (check if the switch is valid)
 \ does not break up partitions repeat switch with new node if invalid (use nx.is_connected())
#4: Compute score for updated(pop/partisan lean/etc.) district config
#5 If new map is better keep changes
 \ If not, accept it anyway with probability R(to be determiend by exp(-kt/T), MonteCarlo Annealing
#6: Repeat process for certain amount of epoch until district configuration is optimized
'''

class Precint:
    def __init__(self, name = "default", id = 0, pop = 0, votes = 0, party_1 = 0, party_2 = 0):
        self.name = name
        self.id = id
        self.pop = pop
        self.votes = votes
        self.party_1 = party_1
        self.party_2 = party_2

test = Precint("test")
#Implement Graph Partition

#Generates square graph used for testing
def nxn_square_graph_gen(n):
    G = nx.Graph()
    for i in range(n**2):
        G.add_node(i)
    edge_list = []
    for j in range(n**2-1):
        if (j % n) == (n-1) and j < n*(n-1):
            edge_list.extend([(j,j+n)])
        elif j >= n*(n-1):
            edge_list.extend([(j,j+1)])
        else:
            edge_list.extend([(j,j+1),(j,j+n)])
    G.add_edges_from(edge_list)
    return G

#Used to convert adj_list generated by networkx into something pymetis can use to generate partition
def adj_list_to_metislist(adj_list):
    list_temp = []
    for line in adj_list:
        list_ = [int(i) for i in line.split(' ')]
        list_.pop(0)
        list_temp.append(list_)
    return list_temp


#Used to convert adj_lists (which is generator class) from networkx into python lists
def nx_gen_object_to_list(gen_object):
    list_temp = []
    for line in gen_object:
        list_ = [line]
        list_temp.extend(list_)
    return list_temp


def return_adj_list_of_graph(G: nx.Graph()) -> list:
    return_list = []
    for node in G.nodes():
        return_list.append([n for n in G.neighbors(node)])
    return return_list

#Take graph (G) and split it into n partitions return list containing lists of partition nodes
def gen_init_part(G: nx.Graph(), n: int) -> list:
    partition_node_list = []
    adj_list = return_adj_list_of_graph(G)
    n_cuts, membership = pymetis.part_graph(n, adjacency=adj_list)
    print(n_cuts)
    print(membership)
    nodes_part_0 = np.argwhere(np.array(membership) == 0).ravel()
    print(nodes_part_0)
    for i in range(n):
        print(i)
        node_temp_list = []
        node_temp_list = np.argwhere(np.array(membership) == i).ravel() #taken from
        # \https://github.com/inducer/pymetis#readme
        #print(node_temp_list)
        partition_node_list.append(node_temp_list)
    return partition_node_list

#Take graph (G) and partion node list and return switch one node from one partition to neighboring partition when valid
# select another node randomly if switch turns out to be invalid(i.e. breaks connection of partition)
def random_switch(G: nx.Graph(), partition_node_list: list) -> (list, bool):
    is_switched = False
    is_node_list_changed = False
    return_list = []
    new_switched_partition_node_list = copy.deepcopy(partition_node_list.copy())  # make deep copy of node list
    random_partition_num = random.randint(0,len(partition_node_list)-1) # select random partition to switch from
    boundary_edge_list = nx_gen_object_to_list(nx.edge_boundary(G, partition_node_list[random_partition_num]))  # boundary edges of partition
    random_boundary_edge_pair_index = random.randint(0,len(boundary_edge_list)-1) # first node is in current partition num second node is partner
    random_boundary_edge_pair = boundary_edge_list[random_boundary_edge_pair_index]
    #find partner partition to switch to
    partner_partition_num = 0
    print(random_boundary_edge_pair)
    for kth_partition in new_switched_partition_node_list:
        if random_boundary_edge_pair[1] in kth_partition:
            break
        else:
            partner_partition_num = partner_partition_num + 1

    #switch between the two random_boundary_edge_pair nodes
    index_loc_0 = np.where(new_switched_partition_node_list[random_partition_num] == random_boundary_edge_pair[0])
    index_loc_1 = np.where(new_switched_partition_node_list[partner_partition_num] == random_boundary_edge_pair[1])
    new_switched_partition_node_list[random_partition_num][index_loc_0], new_switched_partition_node_list[partner_partition_num][index_loc_1] = new_switched_partition_node_list[partner_partition_num][index_loc_1], new_switched_partition_node_list[random_partition_num][index_loc_0]

    #Check if the new partitions are valided(they should be connected)
    part_0 = G.subgraph(new_switched_partition_node_list[random_partition_num])
    part_1 = G.subgraph(new_switched_partition_node_list[partner_partition_num])
    fst_part_connect_state = nx.is_connected(part_0)
    snd_part_connect_state = nx.is_connected(part_1)
    print(random_boundary_edge_pair[0])
    print(random_boundary_edge_pair[1])
    print(new_switched_partition_node_list[random_partition_num])
    print(new_switched_partition_node_list[partner_partition_num])
    print(part_0)
    print(part_1)
    print('part vs new')
    print(partition_node_list)
    print(new_switched_partition_node_list)
    if np.array_equal(np.array(new_switched_partition_node_list, dtype=object),np.array(partition_node_list, dtype=object)):
        is_node_list_changed = False
    else:
        is_node_list_changed = True
    if(fst_part_connect_state and snd_part_connect_state and is_node_list_changed): # is switch valid and actually happened
        print(fst_part_connect_state)
        print(snd_part_connect_state)
        is_switched = True
        return_list = new_switched_partition_node_list
    else:
        print(fst_part_connect_state)
        print(snd_part_connect_state)
        print(is_node_list_changed)
        is_switched = False
        return_list = partition_node_list
    return return_list,is_switched

#Take graph (G) and partion node list and return eat one node from one neighboring partition to neighboring partition
# when valid
# select another node randomly if eat turns out to be invalid(i.e. breaks connection of partition)
def eat_random_node(G: nx.Graph(), partition_node_list: list) -> (list, bool):
    is_eat_true = False
    is_node_list_changed = False
    return_list = []
    is_proper_partition_picked = False
    new_switched_partition_node_list = copy.deepcopy(partition_node_list.copy())  # make deep copy of node list

    #If partner partition has only one node repeat random picking process, should not eliminate partition altogether
    while True:
        random_partition_num = random.randint(0,len(partition_node_list)-1) # select random partition to switch from
        boundary_edge_list = nx_gen_object_to_list(nx.edge_boundary(G, partition_node_list[random_partition_num]))  # boundary edges of partition
        random_boundary_edge_pair_index = random.randint(0,len(boundary_edge_list)-1) # first node is in current partition num second node is partner
        random_boundary_edge_pair = boundary_edge_list[random_boundary_edge_pair_index]
        #find partner partition to eat from
        partner_partition_num = 0
        print(random_boundary_edge_pair)
        #find partner partition number
        for kth_partition in new_switched_partition_node_list:
            if random_boundary_edge_pair[1] in kth_partition:
                break
            else:
                partner_partition_num = partner_partition_num + 1
        if(len(partition_node_list[partner_partition_num]) == 1):
            print("Remaining Node 1 Case Triggered")
            is_proper_partition_picked = False
        else:
            is_proper_partition_picked = True
        if(is_proper_partition_picked == True):
            break

    #For some reason new_switched_partition_node_list[random_partition_num] is treated as numpy narray
    #Use numpy functions instead of list when operating on this.

    #random_partition_num partition will eat the entirety of boudary edge pair nodes
    #index_loc_0 = np.where(new_switched_partition_node_list[random_partition_num] == random_boundary_edge_pair[0])
    index_loc_1 = np.where(new_switched_partition_node_list[partner_partition_num] == random_boundary_edge_pair[1])
    #delete from partner partition (random_boundary_edge_pair[1])
    new_switched_partition_node_list[partner_partition_num] = np.delete(new_switched_partition_node_list[partner_partition_num], index_loc_1)
    #add to random partition
    new_switched_partition_node_list[random_partition_num] = np.append(new_switched_partition_node_list[random_partition_num], random_boundary_edge_pair[1])
    #new_switched_partition_node_list[random_partition_num][index_loc_0], new_switched_partition_node_list[partner_partition_num][index_loc_1] = new_switched_partition_node_list[partner_partition_num][index_loc_1], new_switched_partition_node_list[random_partition_num][index_loc_0]


    #Check if the new partitions are valided(they should be connected)
    part_0 = G.subgraph(new_switched_partition_node_list[random_partition_num])
    part_1 = G.subgraph(new_switched_partition_node_list[partner_partition_num])
    fst_part_connect_state = nx.is_connected(part_0)
    snd_part_connect_state = nx.is_connected(part_1)
    print(random_boundary_edge_pair[0])
    print(random_boundary_edge_pair[1])
    print(new_switched_partition_node_list[random_partition_num])
    print(new_switched_partition_node_list[partner_partition_num])
    print(part_0)
    print(part_1)
    print('part vs new')
    print(partition_node_list)
    print(new_switched_partition_node_list)
    if np.array_equal(np.array(new_switched_partition_node_list, dtype=object),np.array(partition_node_list, dtype=object)):
        is_node_list_changed = False
    else:
        is_node_list_changed = True
    if(fst_part_connect_state and snd_part_connect_state and is_node_list_changed): # is switch valid and actually happened
        print(fst_part_connect_state)
        print(snd_part_connect_state)
        is_eat_true = True
        return_list = new_switched_partition_node_list
    else:
        print(fst_part_connect_state)
        print(snd_part_connect_state)
        print(is_node_list_changed)
        is_eat_true = False
        return_list = partition_node_list
    return return_list,is_eat_true


def print_node_list(node_list):
    for line in node_list:
        print(line)

n = 5
part_num = 3
#G = nxn_square_graph_gen(n)
G = nx.complete_graph(20)
H = nxn_square_graph_gen(n)
partition_node_list = gen_init_part(G, part_num)
print("Original Partition")
print_node_list(partition_node_list)
new_list,state = eat_random_node(G, partition_node_list)
print("New Partition")
print_node_list(new_list)

print("Square Graph")
partition_node_list = gen_init_part(H, part_num)
print("Original Partition")
print_node_list(partition_node_list)
new_list,state = eat_random_node(H, partition_node_list)
print("New Partition")
print_node_list(new_list)
'''
new_list,state = random_switch(G, partition_node_list)
new_list,state = random_switch(G, new_list)
new_list,state = random_switch(G, new_list)
new_list,state = random_switch(G, new_list)
print_node_list(partition_node_list)
print_node_list(new_list)

fig = nx.draw(G,with_labels=True)

sub_graph_0 = G.subgraph(partition_node_list[0])
sub_graph_1 = G.subgraph(partition_node_list[1])
sub_graph_2 = G.subgraph(partition_node_list[2])
nx.draw(sub_graph_0, with_labels=True)
nx.draw(sub_graph_1, with_labels=True)
nx.draw(sub_graph_2, with_labels=True)

sub_graph_0_ = G.subgraph(new_list[0])
sub_graph_1_ = G.subgraph(new_list[1])
sub_graph_2_ = G.subgraph(new_list[2])

nx.draw(sub_graph_0_, with_labels=True)
nx.draw(sub_graph_1_, with_labels=True)
nx.draw(sub_graph_2_, with_labels=True)


plt.show()
'''

print(state)



'''
H = nxn_square_graph_gen(5)


adj_list = nx.generate_adjlist(H)

t = adj_list_to_metislist(adj_list)


n_cuts, membership = pymetis.part_graph(2, adjacency=t)
nodes_part_0 = np.argwhere(np.array(membership) == 0).ravel() # [3, 5, 6]
nodes_part_1 = np.argwhere(np.array(membership) == 1).ravel() # [0, 1, 2, 4]

nodes_part_0 = np.argwhere(np.array(membership) == 0).ravel() # [3, 5, 6]
nodes_part_1 = np.argwhere(np.array(membership) == 1).ravel() # [0, 1, 2, 4]
H_0 = H.subgraph(nodes_part_0)

nx.draw(H_0,with_labels=True)

plt.show()
H_0_boundary = nx.edge_boundary(H,nodes_part_0)
print(nx_gen_object_to_list(H_0_boundary))

H_1 = H.subgraph(nodes_part_1)
nx.draw(H_1, with_labels=True)
plt.show()
H_1_boundary = nx.edge_boundary(H,nodes_part_1)
print(nx_gen_object_to_list(H_1_boundary))

# nx.read_shp('emd.shp')
'''